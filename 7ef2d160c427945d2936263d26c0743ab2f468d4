{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "1dff053b_58bc09e8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2024-08-06T01:43:39Z",
      "side": 1,
      "message": "Hi Alexander, I think we can reduce the moving parts to detect if the client has received expected data, see the comments inline.",
      "revId": "7ef2d160c427945d2936263d26c0743ab2f468d4",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c3996403_e833584c",
        "filename": "test/test-console-client-can-read",
        "patchSetId": 2
      },
      "lineNbr": 20,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2024-08-06T01:43:39Z",
      "side": 1,
      "message": "I\u0027d rather we use:\n\n```\n[ -z \"$CLIENT_PID\" ] || kill \"$CLIENT_PID\"\n```\n\nSame for the cases below. The \"`kill -0` has output\" trick involves yet another subshell when we can just test the variable directly.\n\nFinally, the discussion on the implementation below may impact what cleanup needs to be done here.",
      "range": {
        "startLine": 20,
        "startChar": 2,
        "endLine": 20,
        "endChar": 30
      },
      "revId": "7ef2d160c427945d2936263d26c0743ab2f468d4",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "057a227a_661f1ca8",
        "filename": "test/test-console-client-can-read",
        "patchSetId": 2
      },
      "lineNbr": 20,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2024-08-06T12:18:22Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c3996403_e833584c",
      "range": {
        "startLine": 20,
        "startChar": 2,
        "endLine": 20,
        "endChar": 30
      },
      "revId": "7ef2d160c427945d2936263d26c0743ab2f468d4",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eecc3f16_fd1c0b04",
        "filename": "test/test-console-client-can-read",
        "patchSetId": 2
      },
      "lineNbr": 65,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2024-08-06T01:43:39Z",
      "side": 1,
      "message": "So after a bit of experimentation I think we can simplify this a bit. Here\u0027s the diff that I\u0027ve tested:\n\n```\ndiff --git a/test/test-console-client-can-read b/test/test-console-client-can-read\nindex 6ad6f7ea388e..a39416e103ee 100755\n--- a/test/test-console-client-can-read\n+++ b/test/test-console-client-can-read\n@@ -17,8 +17,7 @@ cd \"$TEST_DIR\"\n \n cleanup()\n {\n-  [ $(kill -0 \"$CLIENT_PID\") ] || kill \"$CLIENT_PID\"\n-  kill -- -$PIPER_PID\n+  [ -z \"$CLIENT_PID\" ] || kill \"$CLIENT_PID\"\n   [ $(kill -0 \"$SERVER_PID\") ] || kill -s INT \"$SERVER_PID\"\n   [ $(kill -0 \"$SOCAT_PID\") ] || kill \"$SOCAT_PID\"\n   wait\n@@ -44,22 +43,13 @@ while ! [ -e remote -a -e local ]; do sleep 1; done\n \n \"$SERVER\" --config \"$TEST_CONF\" \"$(realpath local)\" \u0026\n SERVER_PID\u003d\"$!\"\n-\n while ! busctl status --user xyz.openbmc_project.Console.\"${TEST_NAME}\"; do sleep 1; done\n \n-# create the input pipe for the client and keep it open\n-mkfifo input_pipe\n-setsid sh -c \u0027while true; do sleep 3600; done\u0027 \u003e input_pipe \u0026\n-PIPER_PID\u003d\"$!\"\n-\n-# client should read the message\n-\"$CLIENT\" -i \"$TEST_NAME\" \u003e client-read.txt \u003c input_pipe \u0026\n+socat EXEC:\"$CLIENT -i $TEST_NAME\" EXEC:\u0027grep -m1 -F client-reads-this\u0027 \u0026\n CLIENT_PID\u003d\"$!\"\n \n+echo client-reads-this \u003e remote\n sleep 1\n \n-printf \"client-reads-this\" \u003e remote\n-\n-sleep 1\n-\n-grep -qF client-reads-this client-read.txt\n+! kill -0 \"$CLIENT_PID\"\n+CLIENT_PID\u003d\"\"\n```\n\nWhat do you think?",
      "range": {
        "startLine": 50,
        "startChar": 0,
        "endLine": 65,
        "endChar": 42
      },
      "revId": "7ef2d160c427945d2936263d26c0743ab2f468d4",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c7f94eeb_420184db",
        "filename": "test/test-console-client-can-read",
        "patchSetId": 2
      },
      "lineNbr": 65,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2024-08-06T01:45:24Z",
      "side": 1,
      "message": "Ah, so:\n\n```\n+socat EXEC:\"$CLIENT -i $TEST_NAME\" EXEC:\u0027grep -m1 -F client-reads-this\u0027 \u0026\n```\n\nshould be\n\n```\n+$SOCAT EXEC:\"$CLIENT -i $TEST_NAME\" EXEC:\u0027grep -m1 -F client-reads-this\u0027 \u0026\n```\n\nI meant to fix that before posting but it slipped through the cracks.",
      "parentUuid": "eecc3f16_fd1c0b04",
      "range": {
        "startLine": 50,
        "startChar": 0,
        "endLine": 65,
        "endChar": 42
      },
      "revId": "7ef2d160c427945d2936263d26c0743ab2f468d4",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "26eeca87_4d53538d",
        "filename": "test/test-console-client-can-read",
        "patchSetId": 2
      },
      "lineNbr": 65,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2024-08-06T12:18:22Z",
      "side": 1,
      "message": "The trick with ```grep -m1``` is great, did not know of that before.\nsocat exec is also great.\n\nBut i do not understand how the grep will influence the exit code.\nDid some experiments to confirm this.\n\n```\n[alex@thonkpadT14 ~]$ false \u0026\n[1] 4304\n[1]+  Exit 1                  false\n[alex@thonkpadT14 ~]$ echo $?\n0\n[alex@thonkpadT14 ~]$ false\n[alex@thonkpadT14 ~]$ echo $?\n1\n```\n\nAlso this one\n\n```\n[alex@thonkpadT14 ~]$ false\n[alex@thonkpadT14 ~]$ socat EXEC:\"echo 1234\" EXEC:\"grep -m1 -F 1234\" \u0026\n[1] 4398\n[alex@thonkpadT14 ~]$ 2024/08/06 10:22:40 socat[4398] E write(5, 0x581753aa3000, 5): Broken pipe\n\n[1]+  Exit 1                  socat EXEC:\"echo 1234\" EXEC:\"grep -m1 -F 1234\"\n[alex@thonkpadT14 ~]$ echo $?\n0\n[alex@thonkpadT14 ~]$ socat EXEC:\"echo 1234\" EXEC:\"grep -m1 -F 12345\" \u0026\n[1] 4412\n[alex@thonkpadT14 ~]$ 2024/08/06 10:22:55 socat[4412] W waitpid(): child 4414 exited with status 1\n\n[1]+  Exit 1                  socat EXEC:\"echo 1234\" EXEC:\"grep -m1 -F 12345\"\n[alex@thonkpadT14 ~]$ echo $?\n0\n```\n\nSo the background process does not seem to influence the exit code, which makes sense since it might live on.\n\nAdded a ```wait``` on the socat which will make the grep timeout the test in the failure case.",
      "parentUuid": "c7f94eeb_420184db",
      "range": {
        "startLine": 50,
        "startChar": 0,
        "endLine": 65,
        "endChar": 42
      },
      "revId": "7ef2d160c427945d2936263d26c0743ab2f468d4",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a668df68_7ef7f1bd",
        "filename": "test/test-console-client-can-read",
        "patchSetId": 2
      },
      "lineNbr": 65,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2024-08-07T00:21:20Z",
      "side": 1,
      "message": "\u003e But i do not understand how the grep will influence the exit code.\n\nAh, so I should probably have explained myself a bit more there, just sending you a diff was probably a bit terse ðŸ˜Š\n\nEssentially, the exit code of the grep does not influence the exit code of the script. That may seem surprising, but it\u0027s based on the observation that in the _absence_ of a match `grep -m1` _won\u0027t_ exit: We\u0027ve hooked its input up to an open stream (`stdout` of `obmc-console-client`) and it will keep waiting to read so long as `obmc-console-client` (and `socat`) is running.\n\nA further observation is that if the `EXEC:grep -m1 -F ...` subprocess exits,  which it will when it has a match, the `socat` process will also exit.\n\nCombined, these give us our pass/fail behaviour: If the `socat` process remains running then the grep has not matched, and we have a failure. Alternatively, if the `socat` process has exited we assume the grep has matched and we have success.\n\nSo the exit status of the test is determined by `! kill -0 \"$CLIENT_PID\"`, which is what determines whether our grep has succeeded or not. If we can signal `$CLIENT_PID` then we know that grep can\u0027t have found a match. Conversely, if we can\u0027t signal `$CLIENT_PID` then we assume we have a match. As the semantics are backwards, we use `!` to negate the exit status of `kill`.\n\n\u003e Added a wait on the socat which will make the grep timeout the test in the failure case.\n\nBased on the above, this should be unnecessary. We can determine a failure well before a timeout.",
      "parentUuid": "26eeca87_4d53538d",
      "range": {
        "startLine": 50,
        "startChar": 0,
        "endLine": 65,
        "endChar": 42
      },
      "revId": "7ef2d160c427945d2936263d26c0743ab2f468d4",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "80304d0e_dd8fe847",
        "filename": "test/test-console-client-can-read",
        "patchSetId": 2
      },
      "lineNbr": 65,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2024-08-07T00:47:20Z",
      "side": 1,
      "message": "Oh, the other trick is, because we\u0027re using `set -e`, if `! kill -0 \"$CLIENT_PID\"` is unsuccessful, then we jump straight to `cleanup` before assigning `CLIENT_PID\u003d\"\"`, which means our cleanup handler will `kill \"$CLIENT_PID\"` as we need it to.",
      "parentUuid": "a668df68_7ef7f1bd",
      "range": {
        "startLine": 50,
        "startChar": 0,
        "endLine": 65,
        "endChar": 42
      },
      "revId": "7ef2d160c427945d2936263d26c0743ab2f468d4",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "01d3eb5b_aff32e3a",
        "filename": "test/test-console-client-can-read",
        "patchSetId": 2
      },
      "lineNbr": 65,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2024-08-07T10:00:55Z",
      "side": 1,
      "message": "Just looking at this explanation from a distance already shows how many mental hoops one has to go through to use bash effectively ðŸ˜„\n\nAdded a small comment to summarize your explanations and otherwise changed it to be more in line with your diff.",
      "parentUuid": "80304d0e_dd8fe847",
      "range": {
        "startLine": 50,
        "startChar": 0,
        "endLine": 65,
        "endChar": 42
      },
      "revId": "7ef2d160c427945d2936263d26c0743ab2f468d4",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4dd177d3_9a530b96",
        "filename": "test/test-console-client-can-read",
        "patchSetId": 2
      },
      "lineNbr": 65,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2024-08-07T23:38:48Z",
      "side": 1,
      "message": "\u003e Just looking at this explanation from a distance already shows how many mental hoops one has to go through to use bash effectively ðŸ˜„\n\n`set -e` with `trap` is shell\u0027s exception handling, `\u0026` provides concurrency, `wait` is a join; it\u0027s the same stuff as is available in most other languages, just this language is optimised for handling these in terms of processes.\n\nThat said, I do have a tendency to shrink-wrap things a bit and look for opportunities to make the code more succinct, which is also at play here.\n\n\u003e Added a small comment to summarize your explanations\n\nGreat, thanks.",
      "parentUuid": "01d3eb5b_aff32e3a",
      "range": {
        "startLine": 50,
        "startChar": 0,
        "endLine": 65,
        "endChar": 42
      },
      "revId": "7ef2d160c427945d2936263d26c0743ab2f468d4",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}