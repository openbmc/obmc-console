{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "068b6f86_b464b310",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 11,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2025-02-17T07:07:28Z",
      "side": 1,
      "message": "Can you please elaborate on this? My understanding is that the indexing in the poll event loop in `console-server.c:call_pollers()` will skip a poller. Is that what you\u0027ve observed?",
      "range": {
        "startLine": 11,
        "startChar": 0,
        "endLine": 11,
        "endChar": 32
      },
      "revId": "d00d20e3606729b98acdb85e32f52e07bcdfe448",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f96d05c2_54ececa5",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 11,
      "author": {
        "id": 1000576
      },
      "writtenOn": "2025-02-20T06:52:07Z",
      "side": 1,
      "message": "\u003e Can you please elaborate on this? \n\nthere are 4 place call client_close(), 3 are in poller callback function before return _REMOVE. \nthe client_ringbuffer_poll and client_poll both set the client-\u003erbc \u003d NULL or client-\u003epoller \u003d NULL correspondingly is to avoid client_close unregister the poller within poller callback. this fix is let timeout callback following the same pattern.\n\n\n\u003e My understanding is that the indexing in the poll event loop in `console-server.c:call_pollers()` will skip a poller. \n\nNo, the behavior will be unexpected if this error condition code path executed. Because memory corruption happens, expanding the call_pollers code \n```\n\tfor (i \u003d 0; i \u003c console-\u003en_pollers; i++) {\n\t\tpoller \u003d console-\u003epollers[i];\n\t\tpollfd \u003d \u0026console-\u003epollfds[i];\n\t\tprc \u003d POLLER_OK;\n\n\t\t/* process pending events... */\n\t\tif (pollfd-\u003erevents) {\n\t\t\tprc \u003d poller-\u003eevent_fn(poller-\u003ehandler, pollfd-\u003erevents,\n\t\t\t\t\t       poller-\u003edata);\n\t\t\tif (prc \u003d\u003d POLLER_EXIT) {\n\t\t\t\trc \u003d -1;\n\t\t\t} else if (prc \u003d\u003d POLLER_REMOVE) {\n\t\t\t\tpoller-\u003eremove \u003d true;\n\t\t\t}\n\t\t}\n\n\t\tif ((prc \u003d\u003d POLLER_OK) \u0026\u0026 poller-\u003etimeout_fn \u0026\u0026\n\t\t    timerisset(\u0026poller-\u003etimeout) \u0026\u0026\n\t\t    timercmp(\u0026poller-\u003etimeout, cur_time, \u003c\u003d)) {\n\t\t\t/* One of the ringbuffer consumers is buffering the\n\t\t\tdata stream. The amount of idle time the consumer\n\t\t\tdesired has expired.  Process the buffered data for\n\t\t\ttransmission. */\n\t\t\ttimerclear(\u0026poller-\u003etimeout);\n\t\t\t\n\t\t\t// timeout_fn call console_poller_unregister\n\t\t\t// free the poller and reallocate the whole pollers array\n\t\t\tprc \u003d poller-\u003etimeout_fn(poller-\u003ehandler, poller-\u003edata);\n\t\t\tif (prc \u003d\u003d POLLER_EXIT) {\n\t\t\t\trc \u003d -1;\n\t\t\t} else if (prc \u003d\u003d POLLER_REMOVE) {\n\t\t\t        \n\t\t\t        // here write into memory already freed\n\t\t\t\tpoller-\u003eremove \u003d true;\n\t\t\t}\n\t\t}\n\t}\n}   \t\n```\n\n\u003e Is that what you\u0027ve observed?\n\nSo far, I haven\u0027t observed any unexpected behavior during testing. However, after analyzing the code\u0027s logic, I anticipate that when this timeout error handling code is executed, it will lead to unexpected behavior.",
      "parentUuid": "068b6f86_b464b310",
      "range": {
        "startLine": 11,
        "startChar": 0,
        "endLine": 11,
        "endChar": 32
      },
      "revId": "d00d20e3606729b98acdb85e32f52e07bcdfe448",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b84595a8_41f95102",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 11,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2025-02-20T23:38:58Z",
      "side": 1,
      "message": "Right, yeah, I was looking in the wrong spot. I think there\u0027s possibly another bug with the loop indexing due to the memmove() as well.\n\nAnyway, thanks for the extra details. Can you please add them to the commit message?\n\n\u003e the client_ringbuffer_poll and client_poll both set the client-\u003erbc \u003d NULL or client-\u003epoller \u003d NULL correspondingly is to avoid client_close unregister the poller within poller callback. this fix is let timeout callback following the same pattern.\n\nThis is reasonable. Thanks.",
      "parentUuid": "f96d05c2_54ececa5",
      "range": {
        "startLine": 11,
        "startChar": 0,
        "endLine": 11,
        "endChar": 32
      },
      "revId": "d00d20e3606729b98acdb85e32f52e07bcdfe448",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6341a0c1_78d0dba7",
        "filename": "socket-handler.c",
        "patchSetId": 1
      },
      "lineNbr": 262,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2025-02-17T07:07:28Z",
      "side": 1,
      "message": "This seems a pretty subtle for the behaviour you\u0027re trying to affect. Have you considered other approaches? Perhaps we instead set `client-\u003epoller-\u003eremove \u003d true` in `client_close()` rather than immediately unregister?",
      "revId": "d00d20e3606729b98acdb85e32f52e07bcdfe448",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "94f3129e_877acbb0",
        "filename": "socket-handler.c",
        "patchSetId": 1
      },
      "lineNbr": 262,
      "author": {
        "id": 1000576
      },
      "writtenOn": "2025-02-20T06:52:07Z",
      "side": 1,
      "message": "return POLLER_REMOVE the poller invoker will set poller-\u003eremove \u003d true.\nhttps://github.com/openbmc/obmc-console/blob/master/console-server.c#L893",
      "parentUuid": "6341a0c1_78d0dba7",
      "revId": "d00d20e3606729b98acdb85e32f52e07bcdfe448",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}