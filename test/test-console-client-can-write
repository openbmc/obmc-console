#!/usr/bin/sh

set -eux

SOCAT="$1"
SERVER="$2"
CLIENT="$3"

# Meet DBus bus and path name constraints
TEST_NAME="$(basename "$0" | tr '-' '_')"
TEST_DIR="$(mktemp --tmpdir --directory "$TEST_NAME.XXXXXX")"
SOCAT_PID=""
SERVER_PID=""
CLIENT_PID=""

cd "$TEST_DIR"

cleanup()
{
  if [ -n "$CLIENT_PID" ] && kill -0 "$CLIENT_PID" 2>/dev/null; then
    kill "$CLIENT_PID"
  fi
  if [ -n "$SERVER_PID" ] && kill -0 "$SERVER_PID" 2>/dev/null; then
    kill "$SERVER_PID"
  fi
  if [ -n "$SOCAT_PID" ] && kill -0 "$SOCAT_PID" 2>/dev/null; then
    kill "$SOCAT_PID"
  fi

  wait
  cd -
  rm -rf "$TEST_DIR"
}

trap cleanup EXIT

TEST_CONF="${TEST_NAME}.conf"
TEST_LOG="${TEST_NAME}.log"

cat <<EOF > "$TEST_CONF"
active-console = $TEST_NAME
[$TEST_NAME]
console-id = $TEST_NAME
logfile = $TEST_LOG
EOF

"$SOCAT" PTY,raw,echo=0,link=remote PTY,raw,echo=0,wait-slave,link=local &
SOCAT_PID="$!"
while ! [ -e remote -a -e local ]; do sleep 1; done

"$SERVER" --config "$TEST_CONF" "$(realpath local)" &
SERVER_PID="$!"

sleep 1

# create the input pipe for the client and keep it open
mkfifo input_pipe

# client should read the message
"$CLIENT" -i "$TEST_NAME" > /dev/null < input_pipe &
CLIENT_PID="$!"

sleep 1

echo "client-wrote-this" > input_pipe

sleep 1

cat remote > remote_log &

sleep 1

grep -qF client-wrote-this remote_log
